<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Merry Christmas for ZZQ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        // ================== 全局参数 ==================
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width = window.innerWidth;
        let height = window.innerHeight;
        
        // 适配手机的高分屏（防止模糊）
        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.scale(dpr, dpr);

        // 粒子数量
        const TREE_POINTS = 18000;   
        const GROUND_POINTS = 3000;
        const STAR_POINTS = 800;
        const HEART_POINTS = 600;
        
        // 相机参数
        const CAM_DIST = 13;
        const CAM_HEIGHT = 6.0;
        const PITCH = -0.25;
        const TREE_HEIGHT = 12.0;

        let angle = 0.0;
        const points = []; // 存储所有静态粒子

        // ================== 数学工具 ==================
        function random(min, max) { return Math.random() * (max - min) + min; }
        function randomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

        // ================== 生成粒子 ==================
        
        // 1. 圣诞树
        function initTree() {
            const spiral_n = Math.floor(TREE_POINTS * 0.7);
            const loops = 9;
            
            // 螺旋部分
            for (let i = 0; i < spiral_n; i++) {
                const u = Math.random();
                const h = Math.pow(u, 1.6);
                const y = TREE_HEIGHT * h + 0.2;
                
                let base_r = Math.pow(1 - h, 1.1) * 3.2;
                const branch_wave = Math.max(0, Math.sin((h * 5.8 + 0.15) * Math.PI * 2));
                base_r *= (1.0 + 0.65 * branch_wave);
                
                const t = u * loops * Math.PI * 2;
                const ang = t + random(-0.22, 0.22);
                const r = base_r * random(0.85, 1.08);
                
                const x = Math.cos(ang) * r;
                const z = Math.sin(ang) * r;

                const mid_boost = Math.max(0.15, 1.0 - Math.abs(h - 0.55) * 1.5);
                const base_g = 155 + Math.floor(90 * mid_boost);
                const base_b = 185 + Math.floor(70 * mid_boost);
                
                let col = [255, Math.min(255, base_g + randomInt(-15, 20)), Math.min(255, base_b + randomInt(-15, 35))];
                if (Math.random() < 0.08) { 
                    col = [255, 255 - randomInt(0, 35), 230 + randomInt(0, 25)];
                }
                points.push({x, y, z, c: col});
            }

            // 填充部分
            const fill_n = TREE_POINTS - spiral_n;
            for (let i = 0; i < fill_n; i++) {
                const h = Math.pow(Math.random(), 1.9);
                const y = TREE_HEIGHT * h + 0.2 + random(-0.08, 0.08);
                
                let base_r = Math.pow(1 - h, 1.1) * 4.3;
                const branch_wave = Math.max(0, Math.sin((h * 5.8 + 0.15) * Math.PI * 2));
                base_r *= (1.0 + 0.65 * branch_wave);
                
                const r = base_r * Math.sqrt(Math.random());
                const ang = Math.random() * Math.PI * 2;
                
                const x = Math.cos(ang) * r + random(-0.08, 0.08);
                const z = Math.sin(ang) * r + random(-0.08, 0.08);
                
                const g = randomInt(165, 225);
                const b = randomInt(190, 250);
                points.push({x, y, z, c: [255, g, b]});
            }
        }

        // 2. 地面
        function initGround() {
            const rings = [4.6, 6.0, 7.4, 8.8, 10.2, 11.4];
            for (let i = 0; i < GROUND_POINTS; i++) {
                const ring = rings[Math.floor(Math.random() * rings.length)];
                const r = ring + random(-0.9, 0.9);
                const theta = Math.random() * Math.PI * 2;
                const x = Math.cos(theta) * r;
                const z = Math.sin(theta) * r;
                
                let c = (Math.random() < 0.15) ? randomInt(235, 255) : randomInt(190, 235);
                points.push({x, y: -0.25, z, c: [c, c, 255]});
            }
        }

        // 3. 星星
        function initStars() {
            for (let i = 0; i < STAR_POINTS; i++) {
                const x = random(-18, 18);
                const z = random(-18, 18);
                const y = random(3, 18);
                const base = randomInt(215, 255);
                points.push({x, y, z, c: [base, base, 255]});
            }
        }

        // 4. 爱心 (已修复位置)
        function initHeart() {
            const scale = 0.9;
            const top_y = TREE_HEIGHT + 0.05;
            let count = 0;
            // 确保在原点附近采样
            while (count < HEART_POINTS) {
                const x = random(-1.3, 1.3);
                const y = random(-1.4, 1.4);
                // 心形公式
                const f = Math.pow(x*x + y*y - 1, 3) - x*x * Math.pow(y, 3);
                
                if (f <= 0.0) {
                    // x 和 z 的偏移量非常小，确保居中
                    const wx = x * scale * 0.8;
                    const wy = top_y + (y + 1.0) * scale * 0.5;
                    const wz = random(-0.1, 0.1); 
                    
                    const dist = Math.hypot(x, y);
                    const factor = Math.max(0.35, 1.15 - 0.5 * dist);
                    const g = Math.min(255, Math.max(120, Math.floor(130 * factor + 80)));
                    const b = Math.min(255, Math.max(120, Math.floor(190 * factor + 70)));
                    
                    points.push({x: wx, y: wy, z: wz, c: [255, g, b]});
                    count++;
                }
            }
        }

        // ================== 投影逻辑 ==================
        function project(x, y, z, ang) {
            const cos_a = Math.cos(ang);
            const sin_a = Math.sin(ang);
            
            // 旋转
            const xz = x * cos_a - z * sin_a;
            const zz = x * sin_a + z * cos_a;
            
            // 俯视变换
            const cos_p = Math.cos(PITCH);
            const sin_p = Math.sin(PITCH);
            const yp = y * cos_p - zz * sin_p;
            const zp = y * sin_p + zz * cos_p;
            
            const depth = zp + CAM_DIST;
            const final_y = yp - CAM_HEIGHT;
            
            if (depth <= 0.1) return null;
            
            // 透视投影
            const f = (height * 0.8) / depth; 
            const sx = width / 2 + xz * f;
            const sy = height / 2 - final_y * f;
            
            return {x: sx, y: sy, d: depth};
        }

        // ================== 文字绘制 (全新布局) ==================
        function drawText() {
            // 根据屏幕宽度动态计算字体大小
            const fontSizeBase = Math.max(16, width / 35); 
            const fontSizeLarge = fontSizeBase * 2.2;

            // 计算文本的垂直中心位置 (屏幕上三分之一处)
            const centerY = height / 3;
            // 计算左右文本距离中心的偏移量 (既不挡树，也不太远)
            const textOffset = Math.min(width * 0.18, 160);
            const leftX = width / 2 - textOffset;
            const rightX = width / 2 + textOffset;

            ctx.fillStyle = "#ffcce0"; // 统一使用粉色
            ctx.font = `italic ${fontSizeBase}px "Times New Roman", serif`;

            // 1. To: zzq (左侧，Merry上方，右对齐)
            ctx.textAlign = "right";
            ctx.fillText("To: zzq", leftX, centerY - fontSizeLarge * 0.6);

            // 2. Merry (左侧，中心位置，右对齐)
            ctx.font = `italic ${fontSizeLarge}px "Times New Roman", serif`;
            ctx.textAlign = "right";
            ctx.fillText("Merry", leftX, centerY + fontSizeLarge * 0.3);

            // 3. Christmas (右侧，与Merry同高，左对齐)
            ctx.textAlign = "left";
            ctx.fillText("Christmas", rightX, centerY + fontSizeLarge * 0.3);

            // 4. 2025 (底部，居中)
            ctx.textAlign = "center";
            ctx.font = `italic ${fontSizeBase * 1.3}px "Times New Roman", serif`;
            ctx.fillText("2025", width / 2, height - fontSizeBase * 2.5);
        }

        // ================== 主循环 ==================
        initTree();
        initGround();
        initStars();
        initHeart();

        function animate() {
            // 清空画布
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, width, height);
            
            const drawList = [];
            for (let p of points) {
                const proj = project(p.x, p.y, p.z, angle);
                if (proj) {
                    const size = Math.max(0.5, 3.6 - proj.d * 0.13);
                    drawList.push({
                        x: proj.x, 
                        y: proj.y, 
                        s: size, 
                        c: p.c, 
                        d: proj.d
                    });
                }
            }

            // 按深度排序
            drawList.sort((a, b) => b.d - a.d);

            // 绘制点
            for (let p of drawList) {
                if (p.x >= -5 && p.x <= width+5 && p.y >= -5 && p.y <= height+5) {
                    ctx.fillStyle = `rgb(${p.c[0]}, ${p.c[1]}, ${p.c[2]})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.s, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            drawText();

            angle += 0.0045;
            requestAnimationFrame(animate);
        }

        // 窗口大小改变时重置参数
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
        });

        animate();
    </script>
</body>
</html>
