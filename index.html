<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Merry Christmas for ZZQ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let width = window.innerWidth;
        let height = window.innerHeight;
        
        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.scale(dpr, dpr);

        // 粒子参数
        const TREE_POINTS = 18000;   
        const GROUND_POINTS = 3000;
        const STAR_POINTS = 800;
        const HEART_POINTS = 600;
        
        // === 相机参数修改 (关键) ===
        // 拉远距离，防止顶部和底部被切
        const CAM_DIST = 17.0; 
        const CAM_HEIGHT = 6.0;
        // 稍微抬起镜头角度 (负数越小越接近平视)
        const PITCH = -0.15;
        const TREE_HEIGHT = 12.0;

        let angle = 0.0;
        const points = [];

        // 工具函数
        function random(min, max) { return Math.random() * (max - min) + min; }
        function randomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }

        // ================== 生成粒子 ==================
        
        // 1. 圣诞树 (保持不变)
        function initTree() {
            const spiral_n = Math.floor(TREE_POINTS * 0.7);
            const loops = 9;
            for (let i = 0; i < spiral_n; i++) {
                const u = Math.random();
                const h = Math.pow(u, 1.6);
                const y = TREE_HEIGHT * h + 0.2;
                let base_r = Math.pow(1 - h, 1.1) * 3.2;
                base_r *= (1.0 + 0.65 * Math.max(0, Math.sin((h * 5.8 + 0.15) * Math.PI * 2)));
                const t = u * loops * Math.PI * 2;
                const ang = t + random(-0.22, 0.22);
                const r = base_r * random(0.85, 1.08);
                const x = Math.cos(ang) * r;
                const z = Math.sin(ang) * r;
                const mid_boost = Math.max(0.15, 1.0 - Math.abs(h - 0.55) * 1.5);
                const base_g = 155 + Math.floor(90 * mid_boost);
                const base_b = 185 + Math.floor(70 * mid_boost);
                let col = [255, Math.min(255, base_g + randomInt(-15, 20)), Math.min(255, base_b + randomInt(-15, 35))];
                if (Math.random() < 0.08) col = [255, 255 - randomInt(0, 35), 230 + randomInt(0, 25)];
                points.push({x, y, z, c: col});
            }
            const fill_n = TREE_POINTS - spiral_n;
            for (let i = 0; i < fill_n; i++) {
                const h = Math.pow(Math.random(), 1.9);
                const y = TREE_HEIGHT * h + 0.2 + random(-0.08, 0.08);
                let base_r = Math.pow(1 - h, 1.1) * 4.3;
                base_r *= (1.0 + 0.65 * Math.max(0, Math.sin((h * 5.8 + 0.15) * Math.PI * 2)));
                const r = base_r * Math.sqrt(Math.random());
                const ang = Math.random() * Math.PI * 2;
                const x = Math.cos(ang) * r + random(-0.08, 0.08);
                const z = Math.sin(ang) * r + random(-0.08, 0.08);
                points.push({x, y, z, c: [255, randomInt(165, 225), randomInt(190, 250)]});
            }
        }

        // 2. 地面
        function initGround() {
            const rings = [4.6, 6.0, 7.4, 8.8, 10.2, 11.4];
            for (let i = 0; i < GROUND_POINTS; i++) {
                const ring = rings[Math.floor(Math.random() * rings.length)];
                const r = ring + random(-0.9, 0.9);
                const theta = Math.random() * Math.PI * 2;
                points.push({x: Math.cos(theta) * r, y: -0.25, z: Math.sin(theta) * r, c: [randomInt(190, 255), randomInt(190, 255), 255]});
            }
        }

        // 3. 星星
        function initStars() {
            for (let i = 0; i < STAR_POINTS; i++) {
                const base = randomInt(215, 255);
                points.push({x: random(-18, 18), y: random(3, 18), z: random(-18, 18), c: [base, base, 255]});
            }
        }

        // 4. 爱心 (修改：让它更紧凑地贴在树顶)
        function initHeart() {
            const scale = 0.8; // 稍微减小一点
            const top_y = TREE_HEIGHT;
            let count = 0;
            while (count < HEART_POINTS) {
                const x = random(-1.3, 1.3);
                const y = random(-1.3, 1.3);
                const f = Math.pow(x*x + y*y - 1, 3) - x*x * Math.pow(y, 3);
                if (f <= 0.0) {
                    // 修改高度计算，让它紧贴树尖，不要飞太高
                    const wx = x * scale * 0.7;
                    const wy = top_y + (y + 0.5) * scale * 0.4; 
                    const wz = random(-0.1, 0.1); 
                    
                    const dist = Math.hypot(x, y);
                    const factor = Math.max(0.35, 1.15 - 0.5 * dist);
                    points.push({x: wx, y: wy, z: wz, c: [255, Math.floor(130 * factor + 80), Math.floor(190 * factor + 70)]});
                    count++;
                }
            }
        }

        // ================== 投影逻辑 ==================
        function project(x, y, z, ang) {
            const cos_a = Math.cos(ang); const sin_a = Math.sin(ang);
            const xz = x * cos_a - z * sin_a; const zz = x * sin_a + z * cos_a;
            const cos_p = Math.cos(PITCH); const sin_p = Math.sin(PITCH);
            const yp = y * cos_p - zz * sin_p; const zp = y * sin_p + zz * cos_p;
            const depth = zp + CAM_DIST;
            if (depth <= 0.1) return null;
            // 增大视野范围 (f值越小视野越广)
            const f = (Math.min(width, height) * 0.9) / depth; 
            const sx = width / 2 + xz * f;
            const sy = height / 2 - (yp - CAM_HEIGHT) * f;
            return {x: sx, y: sy, d: depth};
        }

        // ================== 文字绘制 (全新手机垂直布局) ==================
        function drawText() {
            const isPortrait = height > width;
            // 基础字体大小：根据屏幕较窄的一边来计算，保证手机上足够大
            const baseSize = Math.min(width, height) / 20; 
            
            ctx.fillStyle = "#ffcce0";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            const centerX = width / 2;
            // 起始高度：屏幕高度的 15% 处开始
            let currentY = height * 0.15; 

            // 1. To: zzq (加大字体)
            ctx.font = `italic ${baseSize * 2.0}px "Times New Roman", serif`;
            ctx.fillText("To: zzq", centerX, currentY);
            // 增加间距
            currentY += baseSize * 3.0;

            // 2. Merry Christmas (垂直堆叠，大字体)
            ctx.font = `italic ${baseSize * 3.5}px "Times New Roman", serif`;
            ctx.fillText("Merry", centerX, currentY);
            currentY += baseSize * 3.8; // 行间距
            ctx.fillText("Christmas", centerX, currentY);
            currentY += baseSize * 3.5;

            // 3. 2025 (放在 Christmas 下面，字体稍小)
            ctx.font = `italic ${baseSize * 1.8}px "Times New Roman", serif`;
            ctx.fillText("2025", centerX, currentY);
        }

        // ================== 主循环 ==================
        initTree(); initGround(); initStars(); initHeart();

        function animate() {
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, width, height);
            
            const drawList = [];
            for (let p of points) {
                const proj = project(p.x, p.y, p.z, angle);
                if (proj) {
                    // 调整远处粒子大小，让它们更明显
                    const size = Math.max(0.6, 4.0 - proj.d * 0.12);
                    drawList.push({x: proj.x, y: proj.y, s: size, c: p.c, d: proj.d});
                }
            }
            drawList.sort((a, b) => b.d - a.d);
            for (let p of drawList) {
                // 扩大绘制区域，防止边缘粒子突然消失
                if (p.x >= -20 && p.x <= width+20 && p.y >= -20 && p.y <= height+20) {
                    ctx.fillStyle = `rgb(${p.c[0]}, ${p.c[1]}, ${p.c[2]})`;
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.s, 0, Math.PI * 2); ctx.fill();
                }
            }
            drawText();
            angle += 0.004;
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            width = window.innerWidth; height = window.innerHeight;
            canvas.width = width * dpr; canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
        });
        animate();
    </script>
</body>
</html>
